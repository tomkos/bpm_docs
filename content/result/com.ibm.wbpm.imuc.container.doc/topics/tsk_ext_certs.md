# Providing certificates for external routes for Business Automation Workflow on
containers

## About this task

```
oc get route console -n openshift-console -o yaml | grep routerCanonicalHostname
```

Clients connecting to an endpoint need the certificate that is issued for this route, and the
complete list of signer certificates that are used to sign it. Routes use certificates, which must
be signed. A shared domain means that a single HTTPS wildcard certificate can be used to secure all
of these routes. By default, the operator generates these certificates based on a common self-signed
root CA (root\_ca\_secret) that is also generated by the product, although these can
be replaced by a common wildcard certificate.

For each component, you can use individual route parameters to override the following
shared\_configuration settings. See the parameter reference for details. It is
easier to manage routes with shared settings.

1. Hostname changes For hostname changes, obtain the new hostname suffix you would like to use.
If you modify the domain from the default Red Hat OpenShift Container Platform (OCP) domain, then
you are responsible to ensure that the new hostname can resolve to the Red Hat OpenShift router from
inside and outside the OCP cluster. In certain scenarios, the SNI header is required to perform
routing for the Red Hat OpenShift router. Ensure any network device that is involved in handling the
new domain is using the SNI header.
2 Certificate changesFor certificate changes, you need to obtain the necessary certificatefiles in the proper format. When you use custom certificates, you are responsible for managing thelifecycle of the certificates in the secret. The following files are required for the secret in thecertificates.

For certificate changes, you need to obtain the necessary certificate
files in the proper format. When you use custom certificates, you are responsible for managing the
lifecycle of the certificates in the secret. The following files are required for the secret in the
certificates.

    - tls.crt - contains the wildcard server certificate, any intermediate CA
certificates, and the root CA. The file must start with the wildcard server certificate and have the
intermediate CA certificates in order, leading to the root CA at the end of the file.
    - tls.key - contains the private key of the wildcard server certificate.

Each certificate and key must be in an unencrypted PEM format. The PEM encoding uses header and
footer lines for each certificate and private key. The wildcard server certificate must be able to
pass hostname verification for each route. The SAN in the wildcard certificate includes a wildcard
domain match to the domain in your sc\_deployment\_hostname\_suffix. If you cannot use
a wildcard certificate, then you can instead use a certificate that includes a SAN matching the
hostname of each route.

For example, if you have server, intermediate CA, and root CA certificates in the right format in
separate files then this command puts three certificate files into a single file.

```
cat server.crt intermediary.crt root.crt > tls.crt
```

The tls.crt file contains all three certificates. The following example
shows how the certificates are saved in the file.

```
----BEGIN CERTIFICATE----
MIIGxTCCBa2gAwIBAgIQBsfsHm+sdGCWtBjm2GJ5azANBgkqhkiG9w0BAQsFADBN
...
Hnm1QervpJroUVjgCAGnTAcRGs6XDuypQKznlnroQpbbWD0J2dz3dSMSJX2PuLMv
pC5QC+eRr9qc
----END CERTIFICATE----
----BEGIN CERTIFICATE----
MIIGxTCCBa2gAwIBAgIQBsfsHm+sdGCWtBjm2GJ5azANBgkqhkiG9w0BAQsFADBN
...

ZXquzPbsVNypZlQwDEeLJO1QbZcAdwAiRUUHWVUkVpY/oS/x922G4CMmY63AS39d
xoNcbuIPAgAAAXQsQ7RuAAAEAwBIMEYCIQDLwhUk2FPJhSjFz8O/ufO46OdkKsTJ
w2UIHxBlcePdxAIhAM6/ZBftoapGV7k+bzDgBaC4Lc9mTLpoRd1TI1prlm1LAHYA
----END CERTIFICATE----
----BEGIN CERTIFICATE----
MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMScwJQYDVQQDEx5E
aWdpQ2VydCBTSEEyIFNlY3VyZSBTZXJ2ZXIgQ0EwHhcNMjAwODI2MDAwMDAwWhcN
MjIwODMxMTIwMDAwWjCBgjELMAkGA1UEBhMCVVMxETAPBgNVBAgTCE5ldyBZb3Jr
...
pC5QC+eRr9qc
----END CERTIFICATE----
```

## Procedure

1. For certificate changes, create a secret that contains the certificate and private key of your
wildcard certificate. The following command creates a SSL/TLS secret that is named
cp4a-wildcard with the tls.crt and
tls.key that you created.
oc create secret tls cp4a-wildcard --cert tls.crt --key tls.key
2. For certificate changes, set the value of the
shared\_configuration.external\_tls\_certificate\_secret parameter to the name of
the secret that contains your wildcard certificate.
The following example shows updating the deployment with the external TLS certificate secret
set to the cp4a-wildcard
secret. oc patch ICP4ACluster icp4adeploy --type='json' -p '[{"op": "add", "path": "/spec/shared\_configuration/", "value":
 {"external\_tls\_certificate\_secret":"cp4a-wildcard"}}]'
3. For hostname suffix changes, set the value of the
shared\_configuration.sc\_deployment\_hostname\_suffix parameter to the wanted
hostname suffix that includes your new domain. It is recommended to use
<namespace>.<domain> although namespace can be replaced by any unique
identifier that does not exceed 32 characters.  The following example shows updating the
deployment with the hostname suffix set to mynamespace.apps.myocpcluster.com, which
would result in routes with a hostname like
<component>-mynamespace.apps.myocpcluster.com.oc patch ICP4ACluster icp4adeploy --type='json' -p '[{"op": "add", "path": "/spec/shared\_configuration/", "value": 
{"sc\_deployment\_hostname\_suffix":"mynamespace.apps.myocpcluster.com"}}]'